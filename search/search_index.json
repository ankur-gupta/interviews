{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Warning This course is in a very rough shape. Please wait until it has reached a first release. All links here are subject to change. What is this course? \u00b6 This course teaches selected topics in computer science and mathematics in detail with lots of examples. Most of these topics are useful for Software Engineering or ML/Data Scientist interviews; hence the URL. This is not a comprehensive course. This course does not cover everything you need to pass a softwar engineering interview. We highly recommend that you look at many other resources to prepare for interviews. One recommendation is the excellent Cracking the Coding Interview book. Nor is this course a replacement for any formal university or MOOC course in computer science and mathematics. Instead, this course examines some selected topics that are often not covered in sufficient detail in any interview preparation book. The topics we discuss can individually be found in CS or Math textbooks but you may need to search multiple textbooks and combine their knowledge. It is unlikely that you will find the entire selection of topics we discuss in this course in any single textbook. The aim of this course is to provide a serialized knowledge source for some of the mental processes and unsaid, unformalized, interstitial realizations that nearly every person obtains, wittingly or unwittingly, while practicing algorithms. Author(s) of this course have realized a vicious cycle - these ephemeral but essential thought processes and ideas are forgotten when the person is out of practice only to be rediscovered once the person prepares for another interview. It is best for someone to write down these ideas so they are available as needed. Pre-requisites \u00b6 This course is intended for readers who have already obtained or are in the process of obtaining at least one degree in CS, mathematics, engineering, or a similar discipline. The readers must have done some programming before, ideally in python. Assuming that the pre-requisites below are met, each topic in this course is explained in a self-contained style. Most topics discuss the underlying mathematics and provide python code. Ideal Audience \u00b6 Readers who have obtained a degree in a non-CS but technical field (such as chemical engineering, statistics, or physics) are probably the ideal audience for this course. This course may very well contain material that most CS graduates would consider painfully obvious. The reason is that many CS graduates often build up the unsaid, interstitial algorithms knowledge by doing multiple rounds of algorithm courses during their university degree. This is similar to how physical scientists/engineers learn to write a mass/energy balance equation and then just know whether they can solve it analytically or if they need a computer simulation.","title":"Introduction"},{"location":"#introduction","text":"Warning This course is in a very rough shape. Please wait until it has reached a first release. All links here are subject to change.","title":"Introduction"},{"location":"#what-is-this-course","text":"This course teaches selected topics in computer science and mathematics in detail with lots of examples. Most of these topics are useful for Software Engineering or ML/Data Scientist interviews; hence the URL. This is not a comprehensive course. This course does not cover everything you need to pass a softwar engineering interview. We highly recommend that you look at many other resources to prepare for interviews. One recommendation is the excellent Cracking the Coding Interview book. Nor is this course a replacement for any formal university or MOOC course in computer science and mathematics. Instead, this course examines some selected topics that are often not covered in sufficient detail in any interview preparation book. The topics we discuss can individually be found in CS or Math textbooks but you may need to search multiple textbooks and combine their knowledge. It is unlikely that you will find the entire selection of topics we discuss in this course in any single textbook. The aim of this course is to provide a serialized knowledge source for some of the mental processes and unsaid, unformalized, interstitial realizations that nearly every person obtains, wittingly or unwittingly, while practicing algorithms. Author(s) of this course have realized a vicious cycle - these ephemeral but essential thought processes and ideas are forgotten when the person is out of practice only to be rediscovered once the person prepares for another interview. It is best for someone to write down these ideas so they are available as needed.","title":"What is this course?"},{"location":"#pre-requisites","text":"This course is intended for readers who have already obtained or are in the process of obtaining at least one degree in CS, mathematics, engineering, or a similar discipline. The readers must have done some programming before, ideally in python. Assuming that the pre-requisites below are met, each topic in this course is explained in a self-contained style. Most topics discuss the underlying mathematics and provide python code.","title":"Pre-requisites"},{"location":"#ideal-audience","text":"Readers who have obtained a degree in a non-CS but technical field (such as chemical engineering, statistics, or physics) are probably the ideal audience for this course. This course may very well contain material that most CS graduates would consider painfully obvious. The reason is that many CS graduates often build up the unsaid, interstitial algorithms knowledge by doing multiple rounds of algorithm courses during their university degree. This is similar to how physical scientists/engineers learn to write a mass/energy balance equation and then just know whether they can solve it analytically or if they need a computer simulation.","title":"Ideal Audience"},{"location":"how-to-practice/","text":"How to Practice? \u00b6 TBD: Describe what the formal process is. The real treasure is the practice we strengthen along the way \u00b6 Many interview candidates aim to solve as many problems as they can before the interview. They aim to cover as many different topics as they can ranging from Big-O notation to AVL trees. This works for many candidates, especially formal CS graduates. Many of these candidates actually stregnthen their problem solving practice through the series of questions even if they don't realize so. This course takes a different approach. This course is not a mad dash to the solve the most problems. Solving any given problem is not important. Problems are tiny tools to incrementlly improve your practice and mental processes. Each problem you solve using the formal process stengthens your practice and furthur etches in the \"correct\" mental processes to solve a problem. Each problem that you solve by sidestepping the formal process or skipping steps weakens your practice. Thus it is important to use the same formal process for both difficult or previously unseen questions as well as for the simple or previously solved questions. The time spent on solving the easy or previously solved questions via the forma process is the investment that will protect you from haphazard thinking when confronted with a difficult or previously unseen question. Take your time \u00b6 It is essential that you go through this course at your own pace. Don't rush it. Ideally, you should spend 6-12 months preparing for interviews. For every topic, spend time thinking about the problem yourself. Pose questions to yourself and answer them, even if the question seem crazy or irrelevant. It's the mental tussle that'll build your problem solving muscle. Don't get help from anyone \u00b6 If it takes you 2 days to even understand the basic premise of a question, let it take 2 days, even if it takes your friend only 5 minutes to understand the question. Everyone thinks differently and there are myriad of factors that affect your understanding. If you're a physical scientist/engineer, then it is likely that you've been trained to think about different topics of mathematics and your internal requirement for a mathematical proof is much higher (or lower) than a computer scientist. If you're unable to grasp a concept quickly now, then it is likely that you won't be able to grasp a concept during an actual interview quickly. If your mind struggles against ideas, let it struggle and let it anneal into understanding instead of forcing it. Don't read-though the topics leisurely \u00b6 Many candidates simply read through a topic without spending any mental energy on trying to solve it themselves. If you continue to read through any topic in this course, you will read through the solution as well which would deprive you of a possibly irreplacable opportunity. Now that you've read through the solution, you have at least one solution in your mind. Your mind may no longer be willing to look for another solution. Even if you forced yourself to think of an alternative solution, your mind may always converge to the solution that you've just read. There may indeed be no alternative solution, which may make you even more complacent. Wrong solutions are good for you \u00b6 Wrong solutions are good for you. Bad solutions are good for you. Ugly solutions are good for you. All solutions are good during the practice phase, especially if this is your first time practicing these topics using a formal process. If you arrive at a solution that you yourself can prove is incorrect, then retrace your steps to pinpoint the exact mental location where you made the error. Then correct your error and continue the solution. Do this until you are convinced that your solution is correct. Then check the correct answer. There is a chance that even though you were convinced that your solution was finally correct, it wasn't. Repeat. This search-and-destroy operation will provide tremendously more benefit that solving 10 other problems correctly at the first attempts. Bad or ugly solutions are correct but not elegant. They are often complicated and messy and you may have a feeling that a cleaner solution must exist. That is okay. Unless you are an extemely talented genius 1 , you will write ugly solutions, especially for new or difficult problems. The quicker way to learn to write elegant solutions is to spend the mental energy to find the points of ugliness in your solution and confronting them. Often candidates avoid confronting the ugliness, not because they don't have the time, but because it's just uncomfortable to confront your ugly code. Many candidates would write ugly code and then instead of looking at or fixing the ugly code, they will simply discard it. They will then start writing another piece of code to solve the same problem with the hope that in their now latest attempt, they would somehow avoid all the ugliness of the previous attempt. It works, sometimes. Often, every successive attempt only improves code elegance incrementally, requiring multiple sequential attempts. To meta-use the big-O notation, the time complexity of arriving at an acceptably elegant solution may be \\(O(n^2)\\) , where \\(n\\) is the average number of lines in the code 2 . A better solution would be to confront the ugliness, introspect why your brain did what it did, and then attempt to fix all the issues in the second attempt. Footnotes \u00b6 In which case, you shouldn't be reading this. \u21a9 Assuming every attempt only fixes one line of the code at a time. \u21a9","title":"How to practice?"},{"location":"how-to-practice/#how-to-practice","text":"TBD: Describe what the formal process is.","title":"How to Practice?"},{"location":"how-to-practice/#the-real-treasure-is-the-practice-we-strengthen-along-the-way","text":"Many interview candidates aim to solve as many problems as they can before the interview. They aim to cover as many different topics as they can ranging from Big-O notation to AVL trees. This works for many candidates, especially formal CS graduates. Many of these candidates actually stregnthen their problem solving practice through the series of questions even if they don't realize so. This course takes a different approach. This course is not a mad dash to the solve the most problems. Solving any given problem is not important. Problems are tiny tools to incrementlly improve your practice and mental processes. Each problem you solve using the formal process stengthens your practice and furthur etches in the \"correct\" mental processes to solve a problem. Each problem that you solve by sidestepping the formal process or skipping steps weakens your practice. Thus it is important to use the same formal process for both difficult or previously unseen questions as well as for the simple or previously solved questions. The time spent on solving the easy or previously solved questions via the forma process is the investment that will protect you from haphazard thinking when confronted with a difficult or previously unseen question.","title":"The real treasure is the practice we strengthen along the way"},{"location":"how-to-practice/#take-your-time","text":"It is essential that you go through this course at your own pace. Don't rush it. Ideally, you should spend 6-12 months preparing for interviews. For every topic, spend time thinking about the problem yourself. Pose questions to yourself and answer them, even if the question seem crazy or irrelevant. It's the mental tussle that'll build your problem solving muscle.","title":"Take your time"},{"location":"how-to-practice/#dont-get-help-from-anyone","text":"If it takes you 2 days to even understand the basic premise of a question, let it take 2 days, even if it takes your friend only 5 minutes to understand the question. Everyone thinks differently and there are myriad of factors that affect your understanding. If you're a physical scientist/engineer, then it is likely that you've been trained to think about different topics of mathematics and your internal requirement for a mathematical proof is much higher (or lower) than a computer scientist. If you're unable to grasp a concept quickly now, then it is likely that you won't be able to grasp a concept during an actual interview quickly. If your mind struggles against ideas, let it struggle and let it anneal into understanding instead of forcing it.","title":"Don't get help from anyone"},{"location":"how-to-practice/#dont-read-though-the-topics-leisurely","text":"Many candidates simply read through a topic without spending any mental energy on trying to solve it themselves. If you continue to read through any topic in this course, you will read through the solution as well which would deprive you of a possibly irreplacable opportunity. Now that you've read through the solution, you have at least one solution in your mind. Your mind may no longer be willing to look for another solution. Even if you forced yourself to think of an alternative solution, your mind may always converge to the solution that you've just read. There may indeed be no alternative solution, which may make you even more complacent.","title":"Don't read-though the topics leisurely"},{"location":"how-to-practice/#wrong-solutions-are-good-for-you","text":"Wrong solutions are good for you. Bad solutions are good for you. Ugly solutions are good for you. All solutions are good during the practice phase, especially if this is your first time practicing these topics using a formal process. If you arrive at a solution that you yourself can prove is incorrect, then retrace your steps to pinpoint the exact mental location where you made the error. Then correct your error and continue the solution. Do this until you are convinced that your solution is correct. Then check the correct answer. There is a chance that even though you were convinced that your solution was finally correct, it wasn't. Repeat. This search-and-destroy operation will provide tremendously more benefit that solving 10 other problems correctly at the first attempts. Bad or ugly solutions are correct but not elegant. They are often complicated and messy and you may have a feeling that a cleaner solution must exist. That is okay. Unless you are an extemely talented genius 1 , you will write ugly solutions, especially for new or difficult problems. The quicker way to learn to write elegant solutions is to spend the mental energy to find the points of ugliness in your solution and confronting them. Often candidates avoid confronting the ugliness, not because they don't have the time, but because it's just uncomfortable to confront your ugly code. Many candidates would write ugly code and then instead of looking at or fixing the ugly code, they will simply discard it. They will then start writing another piece of code to solve the same problem with the hope that in their now latest attempt, they would somehow avoid all the ugliness of the previous attempt. It works, sometimes. Often, every successive attempt only improves code elegance incrementally, requiring multiple sequential attempts. To meta-use the big-O notation, the time complexity of arriving at an acceptably elegant solution may be \\(O(n^2)\\) , where \\(n\\) is the average number of lines in the code 2 . A better solution would be to confront the ugliness, introspect why your brain did what it did, and then attempt to fix all the issues in the second attempt.","title":"Wrong solutions are good for you"},{"location":"how-to-practice/#footnotes","text":"In which case, you shouldn't be reading this. \u21a9 Assuming every attempt only fixes one line of the code at a time. \u21a9","title":"Footnotes"},{"location":"algorithmic-complexity/precision-is-important/","text":"Precision is important \u00b6 Often candidates are told that precision is not important when computing the time or space complexity. Even more often candidates are told that precision does not matter in a very limited or specific situation but the candidates extrapolate the guidance to take a lax attitude towards complexity. For example CtCI mentions that candidates may think that they're being more precise by saying \\(O(2N)\\) instead of \\(O(N)\\) but they're not. CtCI is correct but some candidates may assume that all constants can be ignored. CtCI immediately provides a good counter example where the constant is indeed quite important. But, this causes another problem for the candidates -- do we now need to remember when the constants are important and when they're not? Some practitioners would argue that with practice you'll learn where the constants are important and when they're not. This is a prime example of unsaid, interstitial knowledge that comes from practicing a large number of complexity problems. We take a different approach to this issue. We follow these rules: Treat constants as important until the very end Being a bit extra precise is better than ignoring something that shouldn't have ignored Formal derivation beats intuition or graphical derivation An example of two recursive calls -- if you ignore the constant, you'll get the wrong complexity. \\(T(n) = c + 2 T(n-1)\\) . Ignore \\(c\\) , see what happens. Complexity is rooted in formal math \u00b6 Often candidates wrongly believe that complexity mathematics is inherently hand-wavy and always informal because: Computing time complexity involves making simplifying assumptions. Since we can never obtain the exact time complexity anyway, why not make any approximation anywhere. Correct though poorly worded statement: \\(O(n)\\) is also \\(O(n^2)\\) But, complexity is a formal statement that is used in non-CS mathematics as well. It has a solid formal footing. This means that derivations of time complexity have rules and you should be careful. It is not until the end of the derivation that you know which terms are important and which are not. This is why it's best to keep all of them around until the very end. When in doubt, use formal definitions \u00b6 If you're unsure whether \\(O(n)\\) is also \\(O(n^2)\\) or \\(O(2n)\\) is also \\(O(n + n^3)\\) , use formal definition of the big-O to derive. Don't guess. Formal definitions are extremely simple to remember and to use. Eventually, you may be able to use the formal definition in your mind without needing pen and paper.","title":"Precision is important"},{"location":"algorithmic-complexity/precision-is-important/#precision-is-important","text":"Often candidates are told that precision is not important when computing the time or space complexity. Even more often candidates are told that precision does not matter in a very limited or specific situation but the candidates extrapolate the guidance to take a lax attitude towards complexity. For example CtCI mentions that candidates may think that they're being more precise by saying \\(O(2N)\\) instead of \\(O(N)\\) but they're not. CtCI is correct but some candidates may assume that all constants can be ignored. CtCI immediately provides a good counter example where the constant is indeed quite important. But, this causes another problem for the candidates -- do we now need to remember when the constants are important and when they're not? Some practitioners would argue that with practice you'll learn where the constants are important and when they're not. This is a prime example of unsaid, interstitial knowledge that comes from practicing a large number of complexity problems. We take a different approach to this issue. We follow these rules: Treat constants as important until the very end Being a bit extra precise is better than ignoring something that shouldn't have ignored Formal derivation beats intuition or graphical derivation An example of two recursive calls -- if you ignore the constant, you'll get the wrong complexity. \\(T(n) = c + 2 T(n-1)\\) . Ignore \\(c\\) , see what happens.","title":"Precision is important"},{"location":"algorithmic-complexity/precision-is-important/#complexity-is-rooted-in-formal-math","text":"Often candidates wrongly believe that complexity mathematics is inherently hand-wavy and always informal because: Computing time complexity involves making simplifying assumptions. Since we can never obtain the exact time complexity anyway, why not make any approximation anywhere. Correct though poorly worded statement: \\(O(n)\\) is also \\(O(n^2)\\) But, complexity is a formal statement that is used in non-CS mathematics as well. It has a solid formal footing. This means that derivations of time complexity have rules and you should be careful. It is not until the end of the derivation that you know which terms are important and which are not. This is why it's best to keep all of them around until the very end.","title":"Complexity is rooted in formal math"},{"location":"algorithmic-complexity/precision-is-important/#when-in-doubt-use-formal-definitions","text":"If you're unsure whether \\(O(n)\\) is also \\(O(n^2)\\) or \\(O(2n)\\) is also \\(O(n + n^3)\\) , use formal definition of the big-O to derive. Don't guess. Formal definitions are extremely simple to remember and to use. Eventually, you may be able to use the formal definition in your mind without needing pen and paper.","title":"When in doubt, use formal definitions"},{"location":"algorithmic-complexity/space-is-not-time/","text":"Space is not Time \u00b6 Recursion with one call versus two calls. Space can be reclaimed but time cannot. Think about punch cards, when space complexity will match time complexity. Same thing, if both of the initial recursive calls are made in parallel in different threads of different processes.","title":"Space is not Time"},{"location":"algorithmic-complexity/space-is-not-time/#space-is-not-time","text":"Recursion with one call versus two calls. Space can be reclaimed but time cannot. Think about punch cards, when space complexity will match time complexity. Same thing, if both of the initial recursive calls are made in parallel in different threads of different processes.","title":"Space is not Time"},{"location":"number-systems/alien-two-stick-measurement-system/","text":"Alien Two-Stick Measurement System \u00b6 Long (7.5 m) and short (1 m) stick.","title":"Alien Two-Stick Measurement System"},{"location":"number-systems/alien-two-stick-measurement-system/#alien-two-stick-measurement-system","text":"Long (7.5 m) and short (1 m) stick.","title":"Alien Two-Stick Measurement System"},{"location":"number-systems/binary-to-hexadecimal/","text":"Binary to Hexadecimal \u00b6 Via Decimal \u00b6 Direct \u00b6","title":"Binary to Hexadecimal"},{"location":"number-systems/binary-to-hexadecimal/#binary-to-hexadecimal","text":"","title":"Binary to Hexadecimal"},{"location":"number-systems/binary-to-hexadecimal/#via-decimal","text":"","title":"Via Decimal"},{"location":"number-systems/binary-to-hexadecimal/#direct","text":"","title":"Direct"},{"location":"number-systems/decimal-is-not-special/","text":"Decimal is not special \u00b6 Numbers don't need decimal. Just have an infinite alphabet.","title":"Decimal is not special"},{"location":"number-systems/decimal-is-not-special/#decimal-is-not-special","text":"Numbers don't need decimal. Just have an infinite alphabet.","title":"Decimal is not special"},{"location":"tips-and-tricks/hashing-to-find-strangers/","text":"Hashing to find strangers \u00b6 Often we need to loop over two loopables (the two loopables could be the same sequence or different sequences or the same sequence but separated by a lag). One common example is looping over pairs of objects from a list of objects.","title":"Hashing to find strangers"},{"location":"tips-and-tricks/hashing-to-find-strangers/#hashing-to-find-strangers","text":"Often we need to loop over two loopables (the two loopables could be the same sequence or different sequences or the same sequence but separated by a lag). One common example is looping over pairs of objects from a list of objects.","title":"Hashing to find strangers"},{"location":"tips-and-tricks/rolling-window/","text":"Rolling Window \u00b6 For anything that involves a sequence (string or a sequence of numbers or a stream of objects), consider if a rolling approach would work. This often reduces the time complexity.","title":"Rolling Window"},{"location":"tips-and-tricks/rolling-window/#rolling-window","text":"For anything that involves a sequence (string or a sequence of numbers or a stream of objects), consider if a rolling approach would work. This often reduces the time complexity.","title":"Rolling Window"}]}